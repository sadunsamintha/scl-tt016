# DEVICES BEHAVIOR 
################################################################################

# standard/simulator
remoteServer.behavior=simulator
camera.behavior=simulator
printer.behavior=simulator
plc.behavior=simulator

# standard/simulator/none
brs.behavior=none
bis.behavior=none

# use barcode reader device to select the SKU to produce - true/false
useBarcodeReader=false

#Leibinger user level
leibinger.user.level.admin=0
leibinger.user.level.operator=1



# PLC
################################################################################

# plc:jb://<local computer AMS Net Id>#<PLC AMS Net Id>@<PLC IP>
plc.ip=plc:jb://192.168.1.1.1.1#5.5.25.42.69.100@192.168.1.3/lifeCheckInterval=1000;lifeCheckTimeout=5000;adsRuntimePort=801


# SERVER (MASTER SCL OR DMS)
################################################################################

# specified user credentials and subsystem must match ones on server DB
server.machine.user=scl4-casa
server.machine.password=1234
server.machine.subsystemId=504

# should only need to change the server IP. Port should always be the same
server.url=jnp://10.2.66.186:1099

# how many seconds the app will wait for a response from remote server after a request, before it timeouts
remoteServerTimeoutCall_sec=60
# how many seconds the app will wait for a response from remote server after a lifecheck request was made
remoteServerLifeCheckTimeoutCall_sec=10
# number of seconds between a lifecheck request to the remote server
server.lifecheck.delay.sec=20


# list of code types for which we don't want to download encoders. This property is important if the app is
# running on SAS mode, because we don't need and want to download encoders for the code types produced - comma
# separated values
encoder.download.codetype.filter=

# code type or product type for this line - should be configurable according to type of product being produced.
codeTypeId=3

# should we switch off printer if we exit the app?
exit.printer.switchoff=true


# BIS (BRAND IDENTIFICATION SYSTEM)
################################################################################

bis.ip=192.168.1.41
bis.port=8020

# app is blocked if BIS is disconnected - true/false
bis.disconnected.production.block=true
# time interval between which the app checks the connection with the BIS - unit is seconds
bis.connectionLifeCheckInterval.sec=5
# time interval between which the app sends the BIS credentials to the BIS - unit is minutes
bis.credential.sending.period.min=5
# Unknown SKU identifier for Domestic. When BIS can't recognize the product, this is the SKU which will be assigned to the products.
# This SKU identifier must exist in the server
bis.unknownSkuId.domestic=3164761
# Unknown SKU identifier for Export.
bis.unknownSkuId.export=3164991
# Display alerts received from BIS on the SCL GUI
bis.displayAlertMessage=true


# BRS (BARCODE RECOGNITION SYSTEM)
################################################################################

# time in milliseconds between a lifecheck request
brs.lifecheck.interval = 1000
# time in milliseconds the app waits for a response after a lifecheck request
brs.lifecheck.timeout = 2000
# number of lifecheck retries
brs.lifecheck.retries = 3


# GLOBAL PROPERTIES
################################################################################
# name of the app which is displayed during boot
custo.id=TT016
# language of the app - fr/en
language=fr
# number of lines managed by the app. Usually there's only 1 line
line.count=1
# line identifier which is displayed on the header of the GUI. If blank, the lineID will take the subsystem value
# received from the server. Can take any value
lineId=123456
# subsystem received from the server. Shouldn't be defined
subsystemId=123456
# crypto password. Don't change
sicpadataPassword=admin

# minimum number of encoders stored locally. If number of encoders is equal or less than value defined, the
# app will make a request for a number of encoders equal to the number of encoders defined by the property
# "requestNumberEncoders" defined below
minEncodersThreshold=1
# number of encoders requested by the app, for each request.
requestNumberEncoders=2

# Blob detection (or ink detected) has 3 modes : NONE, ALWAYS and STANDARD.
# NONE means that app will disable blob detection. The app won't distinguish a product without ink from one with - both
# products will be counted as invalid.
# ALWAYS means that the blob detection will be enabled for every SKU.
# STANDARD means that the blob detection will be enabled according to whether a product is compliant or not
blobDetection.mode=ALWAYS
#if this property is setted to false, then the blob pattern is not printed.
blobDetection.printed=false

# PRINTER EXTENDED CODE CONFIG
########################################
dm.format=DM_8x18
dm.encoding=ASCII
dm.orientation=REVERSE

blob.position=RIGHT
blob.type=BLOB_2D
#BLOB_2D


# ejection system enabled? - true/false
heuftSystem=true

# is refeed mode available? this property is downloaded from server during app boot. Shouldn't be manually defined
refeedAvailable=true

# display or not an animation every time the app receives a code from the camera
displayProductionStatusBar=true

# EJECTION TYPE CONFIGURATION
# Overide for ejection type for the PLC
# The default value sent to PLC and is stored in line*.properties file as PARAM_LINE_EJECTION_TYPE
# Current supported types are
# no_read_ejection(1) - . Will only eject if DM cannot be read
# no_ink_detection(2) - . Will eject if no ink is detected
# The values below will override this value dependinng on the selected production mode

# USAGE
# ejection.type.{productionmode.standard|productionmode.export|productionmode.refeed.normal|productionmode.maintenance}={no_read_ejection|no_ink_ejection}
# If productionmode.* does not have a defined ejection strategy the "ejection.type.default" value will be used

# Properties describing the ejection strategies which are supported in the PLC
# These are used in tt016.groovy file for defining the ejection_type at runtime depending on the production mode selected
ejection_type.no_read_ejection=1
ejection_type.no_ink_ejection=2

ejection.type.default=${ejection_type.no_ink_ejection}
ejection.type.productionmode.refeed.normal=${ejection_type.no_read_ejection}






# SKU SELECTION / RECOGNITION
################################################################################

# when SKU is recognized, should the app automatically select it (selector)? Or should it compare it with the
# current selected SKU (check)? For BIS use the value "selector", for BRS use value "check" - selector/check/none
sku.recognition.behavior=none

# how is the SKU selected? Does the operator manually selects it (operator_full)? Or only selects the production mode
# and the app will select the SKU automatically (operator_partial)? - operator_full/operator_partial
#operator_full / operator_partial
skuSelection.behavior=operator_full

# number of recognition results received after which the SCL will determine the most occurring SKU and take action.
# See "sku.recognition.behavior"
sku.recognition.input.buffer=10

# number of minutes after which the app will reset the SKU selection if no recognition result is received. This
# number should be defined according to the time it usually takes the producer/manufacturer
sku.recognition.production.change.timer.minute=5

# enable or disable unknown SKU alert. If alert is raised, SCL will order the BIS to save images of the unknown product
alert.sku.recognition.unknown.enabled=true
# max number of unknown SKU products after which the alert is raised. E.g.: for a sampleSize of 20, and a
# maxUnknownCount of 10. The alert will be evaluated every 20 products and if the max number of unknown SKU products
# is higher than 10, the alert will be raised
alert.sku.recognition.unknown.maxUnknownCount=10
# number of products after which the unknown SKU alert is evaluated
alert.sku.recognition.unknown.sampleSize=20

# enable or disable the unknown buffer mechanism. If using BIS or BRS and the option "skuSelection.behavior" is
# "operator_partial", then this option should be enabled (unknown_buffer) - unknown_buffer/standard
production.behavior=standard
# max number of products stored in buffer with unknown SKU before being saved to disk. If SCL automatically selects the
# number of products in buffer < max buffer size. All the products in buffer will be assigned the new SKU. It's
# important that the size of the buffer to be bigger than the property "sku.recognition.input.buffer". If max size is
# reached products will be flushed and saved to disk
production.with_unknown_buffer.buffer.size=30
# how often the buffer is flushed and products in it saved to disk
production.with_unknown_buffer.task.unknown.delay.sec=30


# STATISTICS
################################################################################

# hide or show "produit marque" counter - true/false
statistics.view.visible.key.stats.display.good=true

# hide or show "sans marque" counter - true/false
statistics.view.visible.key.stats.display.bad=true

# hide or show "non conforme producteur" counter - true/false
statistics.view.visible.key.stats.display.ejectedProducer=true

# hide or show "produit illisible" counter - true/false
statistics.view.visible.key.stats.display.inkDetected=true

# hide or show "total number of products" counter - true/false
statistics.view.visible.total=true

# hide or show "vitesse de la ligne" information - true/false
statistics.view.visible.speed=true


# ALERTS
################################################################################

# all the following alerts work more or less in the same way.
#
# the ".enabled" specifies the whether the alert is enabled or disabled - true/false
# the ".delayInSec" property specifies the time in seconds between successive alert evaluations
# the ".maxUnreadCount" and ".threshold" properties, specify the max number of errors after which the alert is raised
# the ".sampleSize" prpoperty specifies the number of products after which the alert is evaluated

# SANS MARQUE ERROR - app will stop production
alert.cameraCount.error.enabled=true
alert.cameraCount.error.delayInSec=5
alert.cameraCount.error.maxUnreadCount=10
alert.cameraCount.error.sampleSize=50

# SANS MARQUE WARNING - app will raise a warning
alert.cameraCount.warning.enabled=true
alert.cameraCount.warning.delayInSec=5
alert.cameraCount.warning.maxUnreadCount=5
alert.cameraCount.warning.sampleSize=50

# BRS unread barcode
alert.unreadbarcodes.enable=true
alert.unreadbarcodes.warning.threshold=100
alert.unreadbarcodes.error.threshold=105

# BRS wrong barcode
alert.wrongBarcode.enable=true
alert.wrongBarcode.error.threshold=10
# time in milliseconds between successive alert evaluations. 60000 milliseconds = 1 minute
alert.wrongBarcode.window.time=60000

# DUPLICATE CODE - if more than a specific number of duplicate codes is found a warning will be displayed
alert.duplicatedCode.enabled=true
alert.duplicatedCode.threshold=5

# CAMERA IDLE - if operator started production and camera wasn't trigger for some time, an error is raised and
# production stops
alert.cameraIddle.enabled=false
alert.cameraIddle.delayInSec=30
alert.cameraIddle.maxInactiveTimeInSec=60

# PLC ACTIVATION CROSSCHECK - if the difference between the product sensor (sensor used by PLC to trigger devices)
# and product counter is bigger than the "maxDelta", an alert will be raised and an error will be displayed.
# Production will stop
alert.plcActivationCrossCheck.enabled=false
alert.plcActivationCrossCheck.delay.sec=5
alert.plcActivationCrossCheck.maxDelta=10

# NO CAPS
alert.noCaps.enabled=true
alert.noCaps.delayInSec=5
alert.noCaps.threshold=5
alert.noCaps.sampleSize=10


# SCHEDULERS CONFIG
################################################################################

# how often we are saving products to disk
productionSerializationTimer_sec=5
# how often the products saved on disk are packaged, so they are ready to be sent to server
packagedProductTimer_sec=100
# how often we are sending the production data to the server
productionSendTimer_sec=300
# how often the SCL app requests the production parameters (SKU list) to the server
getProductionParametersTimer_sec=7200
# how often the SCL app requests the authenticator/decoder to the server
getAuthenticathorTimer_sec=7200
# how often the SCL app performs a deletion of old production data  in the "sent" folder which are older than 30 days
storageProductionCleanUp_sec=7200
# how often the SCL app retrieves the language files from server - non applicable for MA
getLanguageFilesTimer_sec=7200
# max number of seconds the SCL app can produce without connection to server
maxRemoteServerDownTimeTimer_sec=600
# how often we are saving the current production statistics to disk
saveStatisticsTimer_sec=60
# how often we are saving the incremental statistics to disk
monitoringSaveIncrementalStatisticsTimer_sec=300
# how often the SCL app sends monitoring data to server - non applicable for MA. MA uses JMX solution for monitoring
globalMonitoringToolSendInfoTimer_sec=300
# how often the SCL app requests encoders to the server
getEncodersTimer_sec=300
# maximum allowed time the app can produce without being connected to the remote server
remoteServerMaxDownTime_day=60
# production data successfully sent to remote server older than X days will be deleted
cleanUpSendDataThreshold_day=30
# maximum number of products to send with each batch
productionSendBatchSize=5000





# PRODUCTION
################################################################################
# Production config folder
# This value must correspond to a production config folder within the $profile/config directory
# At the time of writing the two possible values were "productionConfig-SAS" or "productionConfig-SCL"
production.config.folder=productionConfig-SCL

